/**
 * ุงุฎุชุจุงุฑุงุช ููููุงุช ุงูุชุบุฐูุฉ ุงูุฑุงุฌุนุฉ ูุชุญุณููุงุช UX
 * Recommendation Feedback & UX Tests
 */

import { describe, it, expect, beforeEach, afterEach } from '@jest/globals';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import '@testing-library/jest-dom';

// Mock ููููููุงุช
const mockTrackEvent = jest.fn();
jest.mock('@/lib/analytics-core', () => ({
  trackEvent: mockTrackEvent,
  EventType: {
    FEATURE_USE: 'feature_use',
    ARTICLE_LIKE: 'article_like',
  }
}));

describe('๐จ ุงุฎุชุจุงุฑุงุช ุชุญุณููุงุช ุชุฌุฑุจุฉ ุงููุณุชุฎุฏู', () => {
  
  beforeEach(() => {
    mockTrackEvent.mockClear();
    // Mock fetch ููู API calls
    global.fetch = jest.fn();
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  describe('ูููู ุงูุชุบุฐูุฉ ุงูุฑุงุฌุนุฉ', () => {
    
    it('should display recommendation reason correctly', () => {
      const reasonText = 'ูุฃูู ุชูุฑุฃ ููุงูุงุช ูุดุงุจูุฉ ูู ุงูุชูููุฉ';
      const reasonType = 'interest';

      // ูุญุงูุงุฉ ุนุฑุถ ุงููููู
      expect(reasonText).toContain('ุชูููุฉ');
      expect(reasonType).toBe('interest');
    });

    it('should show feedback buttons', async () => {
      // ูุญุงูุงุฉ ูุฌูุฏ ุฃุฒุฑุงุฑ ุงูุชูููู
      const feedbackButtons = [
        'ูุงุถุญ ููููุฏ',
        'ุบูุฑ ูุงุถุญ', 
        'ูููุฏ',
        'ุบูุฑ ูููุฏ'
      ];

      feedbackButtons.forEach(buttonText => {
        expect(buttonText).toBeTruthy();
      });
    });

    it('should handle feedback submission', async () => {
      const mockSubmit = jest.fn();
      
      // ูุญุงูุงุฉ ุฅุฑุณุงู ุงูุชุบุฐูุฉ ุงูุฑุงุฌุนุฉ
      const feedbackData = {
        recommendationId: 'rec_123',
        reasonText: 'test reason',
        feedback: 'clear',
        note: 'test note'
      };

      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        json: () => Promise.resolve({ success: true })
      });

      const response = await fetch('/api/feedback/reason', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(feedbackData)
      });

      expect(response.ok).toBe(true);
      expect(global.fetch).toHaveBeenCalledWith(
        '/api/feedback/reason',
        expect.objectContaining({
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(feedbackData)
        })
      );
    });

    it('should track feedback events', () => {
      // ูุญุงูุงุฉ ุชุชุจุน ุงูุฃุญุฏุงุซ
      mockTrackEvent('feature_use', {
        feature: 'recommendation_reason_feedback',
        feedback: 'clear',
        recommendationId: 'rec_123'
      });

      expect(mockTrackEvent).toHaveBeenCalledWith(
        'feature_use',
        expect.objectContaining({
          feature: 'recommendation_reason_feedback',
          feedback: 'clear'
        })
      );
    });
  });

  describe('API ุงูุชุบุฐูุฉ ุงูุฑุงุฌุนุฉ', () => {
    
    it('should accept valid feedback data', async () => {
      const validFeedback = {
        recommendationId: 'rec_123',
        reasonText: 'ูุฃูู ููุชู ุจุงูุชูููุฉ',
        feedback: 'clear',
        note: 'ุงูุณุจุจ ูุงุถุญ ุฌุฏุงู'
      };

      // ูุญุงูุงุฉ ุงุณุชุฌุงุจุฉ API ูุงุฌุญุฉ
      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        json: () => Promise.resolve({
          success: true,
          feedbackId: 'feedback_456'
        })
      });

      const response = await fetch('/api/feedback/reason', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(validFeedback)
      });

      const data = await response.json();
      
      expect(response.ok).toBe(true);
      expect(data.success).toBe(true);
      expect(data.feedbackId).toBeTruthy();
    });

    it('should reject invalid feedback data', async () => {
      const invalidFeedback = {
        // ุจูุงูุงุช ูุงูุตุฉ
        feedback: 'invalid_type'
      };

      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: false,
        status: 400,
        json: () => Promise.resolve({
          success: false,
          error: 'ุจูุงูุงุช ุบูุฑ ุตุญูุญุฉ'
        })
      });

      const response = await fetch('/api/feedback/reason', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(invalidFeedback)
      });

      expect(response.ok).toBe(false);
      expect(response.status).toBe(400);
    });

    it('should return feedback statistics', async () => {
      const mockStats = {
        success: true,
        stats: {
          total: 100,
          by_type: {
            clear: 40,
            helpful: 30,
            unclear: 20,
            not_helpful: 10
          },
          satisfaction_rate: 70,
          with_notes: 25,
          with_improvements: 15
        }
      };

      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        json: () => Promise.resolve(mockStats)
      });

      const response = await fetch('/api/feedback/reason?timeframe=7d');
      const data = await response.json();

      expect(response.ok).toBe(true);
      expect(data.stats.total).toBe(100);
      expect(data.stats.satisfaction_rate).toBe(70);
    });
  });

  describe('ูููู ุชุบุฐูุฉ ุงูููุงูุงุช', () => {
    
    it('should display recommendations with reasons', () => {
      const mockRecommendations = [
        {
          id: 'article_1',
          title: 'ููุงู ุชููู ุฑุงุฆุน',
          recommendation_reason: 'ูุฃูู ุชูุฑุฃ ุนู ุงูุชูููุฉ',
          recommendation_type: 'interest',
          recommendation_score: 0.9
        }
      ];

      mockRecommendations.forEach(rec => {
        expect(rec.recommendation_reason).toBeTruthy();
        expect(rec.recommendation_type).toBe('interest');
        expect(rec.recommendation_score).toBeGreaterThan(0);
      });
    });

    it('should handle recommendation refresh', async () => {
      // ูุญุงูุงุฉ ุชุญุฏูุซ ุงูุชูุตูุงุช
      const mockNewRecommendations = [
        { id: 'new_1', title: 'ููุงู ุฌุฏูุฏ 1' },
        { id: 'new_2', title: 'ููุงู ุฌุฏูุฏ 2' }
      ];

      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        json: () => Promise.resolve({
          recommendations: mockNewRecommendations
        })
      });

      const response = await fetch('/api/ml/recommendations', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          user_events: [],
          articles: [],
          top_n: 5
        })
      });

      const data = await response.json();
      
      expect(response.ok).toBe(true);
      expect(data.recommendations).toHaveLength(2);
    });

    it('should track article interactions', () => {
      // ูุญุงูุงุฉ ุชุชุจุน ุงูุชูุงุนู ูุน ุงูููุงูุงุช
      const articleData = {
        articleId: 'article_123',
        action: 'view',
        context: 'recommendation',
        recommendation_score: 0.85
      };

      mockTrackEvent('article_view', articleData);

      expect(mockTrackEvent).toHaveBeenCalledWith(
        'article_view',
        expect.objectContaining({
          articleId: 'article_123',
          recommendation_score: 0.85
        })
      );
    });
  });

  describe('ููุญุฉ ุชุญููู ุงูุชุบุฐูุฉ ุงูุฑุงุฌุนุฉ', () => {
    
    it('should display key metrics', () => {
      const mockMetrics = {
        total: 500,
        satisfaction_rate: 75.5,
        with_notes: 120,
        with_improvements: 80
      };

      // ุงูุชุญูู ูู ูุฌูุฏ ุงูููุงููุณ ุงูุฃุณุงุณูุฉ
      expect(mockMetrics.total).toBeGreaterThan(0);
      expect(mockMetrics.satisfaction_rate).toBeGreaterThanOrEqual(0);
      expect(mockMetrics.satisfaction_rate).toBeLessThanOrEqual(100);
      expect(mockMetrics.with_notes).toBeGreaterThanOrEqual(0);
      expect(mockMetrics.with_improvements).toBeGreaterThanOrEqual(0);
    });

    it('should filter data by timeframe', async () => {
      const timeframes = ['1d', '7d', '30d'];
      
      for (const timeframe of timeframes) {
        (global.fetch as jest.Mock).mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve({
            stats: { total: 100 },
            timeframe
          })
        });

        const response = await fetch(`/api/feedback/reason?timeframe=${timeframe}`);
        const data = await response.json();

        expect(response.ok).toBe(true);
        expect(data.timeframe).toBe(timeframe);
      }
    });

    it('should show recent feedback items', () => {
      const mockRecentFeedback = [
        {
          id: 'feedback_1',
          feedback: 'clear',
          note: 'ุงูุณุจุจ ูุงุถุญ',
          created_at: '2024-01-15T10:00:00Z',
          reason_text: 'ูุฃูู ุชูุฑุฃ ุนู ุงูุชูููุฉ'
        },
        {
          id: 'feedback_2', 
          feedback: 'unclear',
          improvement_suggestion: 'ูููู ุชุญุณูู ุงูุตูุงุบุฉ',
          created_at: '2024-01-15T11:00:00Z',
          reason_text: 'ูุญุชูู ุดุงุฆุน'
        }
      ];

      mockRecentFeedback.forEach(item => {
        expect(item.id).toBeTruthy();
        expect(['clear', 'unclear', 'helpful', 'not_helpful']).toContain(item.feedback);
        expect(item.created_at).toBeTruthy();
        expect(item.reason_text).toBeTruthy();
      });
    });
  });

  describe('ุชุญุณููุงุช ุชุฌุฑุจุฉ ุงููุณุชุฎุฏู', () => {
    
    it('should provide clear recommendation reasons', () => {
      const reasons = [
        'ูุฃูู ุชูุฑุฃ ููุงูุงุช ูุดุงุจูุฉ ูู ุงูุชูููุฉ',
        'ูุฐุง ุงูููุงู ุดุงุฆุน ุจูู ุงููุฑุงุก',
        'ูุนุฌุจ ุงููุณุชุฎุฏููู ุงููุดุงุจููู ูู',
        'ูุญุชูู ุฌุฏูุฏ ูุฏ ูุซูุฑ ุงูุชูุงูู'
      ];

      reasons.forEach(reason => {
        expect(reason.length).toBeGreaterThan(10);
        expect(reason).toMatch(/ูุฃู|ูุฐุง|ูุนุฌุจ|ูุญุชูู/);
      });
    });

    it('should use appropriate icons and colors', () => {
      const reasonTypes = {
        interest: { icon: '๐ฏ', color: 'blue' },
        popular: { icon: '๐ฅ', color: 'red' },
        collaborative: { icon: '๐ฅ', color: 'green' },
        diversity: { icon: '๐', color: 'purple' },
        freshness: { icon: 'โจ', color: 'yellow' }
      };

      Object.entries(reasonTypes).forEach(([type, config]) => {
        expect(config.icon).toBeTruthy();
        expect(config.color).toBeTruthy();
        expect(type).toBeTruthy();
      });
    });

    it('should handle accessibility requirements', () => {
      // ูุญุงูุงุฉ ูุญุต ุฅููุงููุฉ ุงููุตูู
      const accessibilityFeatures = [
        'keyboard_navigation',
        'screen_reader_support', 
        'color_contrast',
        'focus_indicators',
        'aria_labels'
      ];

      accessibilityFeatures.forEach(feature => {
        expect(feature).toBeTruthy();
      });
    });

    it('should be responsive across devices', () => {
      // ูุญุงูุงุฉ ุงุฎุชุจุงุฑ ุงูุงุณุชุฌุงุจุฉ
      const breakpoints = {
        mobile: 768,
        tablet: 1024,
        desktop: 1200
      };

      Object.entries(breakpoints).forEach(([device, width]) => {
        expect(width).toBeGreaterThan(0);
        expect(device).toBeTruthy();
      });
    });
  });

  describe('ุณููุงุฑูููุงุช ูุชูุงููุฉ', () => {
    
    it('should complete full feedback flow', async () => {
      // 1. ุนุฑุถ ุงูุชูุตูุฉ
      const recommendation = {
        id: 'rec_123',
        reason: 'ูุฃูู ุชูุฑุฃ ุนู ุงูุฐูุงุก ุงูุงุตุทูุงุนู',
        type: 'interest'
      };

      // 2. ุชูููู ุงููุณุชุฎุฏู
      const feedback = {
        recommendationId: recommendation.id,
        reasonText: recommendation.reason,
        feedback: 'clear',
        note: 'ุงูุณุจุจ ูุงุถุญ ููููุฏ'
      };

      // 3. ุฅุฑุณุงู ุงูุชุบุฐูุฉ ุงูุฑุงุฌุนุฉ
      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        json: () => Promise.resolve({ success: true })
      });

      const response = await fetch('/api/feedback/reason', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(feedback)
      });

      // 4. ุงูุชุญูู ูู ุงููุชุงุฆุฌ
      expect(response.ok).toBe(true);
      expect(recommendation.reason).toContain('ุงูุฐูุงุก ุงูุงุตุทูุงุนู');
      expect(feedback.feedback).toBe('clear');
    });

    it('should handle error scenarios gracefully', async () => {
      // ูุญุงูุงุฉ ุฎุทุฃ ูู ุงูุดุจูุฉ
      (global.fetch as jest.Mock).mockRejectedValueOnce(
        new Error('Network error')
      );

      try {
        await fetch('/api/feedback/reason', {
          method: 'POST',
          body: JSON.stringify({ invalid: 'data' })
        });
      } catch (error) {
        expect(error).toBeInstanceOf(Error);
        expect((error as Error).message).toBe('Network error');
      }
    });

    it('should improve recommendations over time', () => {
      // ูุญุงูุงุฉ ุชุญุณู ุงูุชูุตูุงุช ูุน ุงูููุช
      const feedbackHistory = [
        { timestamp: '2024-01-01', satisfaction: 60 },
        { timestamp: '2024-01-08', satisfaction: 65 },
        { timestamp: '2024-01-15', satisfaction: 72 }
      ];

      // ุงูุชุญูู ูู ุชุญุณู ูุนุฏู ุงูุฑุถุง
      const improvements = feedbackHistory.map((item, index) => {
        if (index === 0) return 0;
        return item.satisfaction - feedbackHistory[index - 1].satisfaction;
      });

      const totalImprovement = improvements.reduce((sum, imp) => sum + imp, 0);
      expect(totalImprovement).toBeGreaterThan(0);
    });
  });
});

// ุชูุธูู ุจุนุฏ ุงูุงุฎุชุจุงุฑุงุช
afterAll(() => {
  console.log('๐งน ุชูุธูู ุงุฎุชุจุงุฑุงุช ุชุญุณููุงุช UX...');
});

// ุฅุนุฏุงุฏ ูุจู ุงูุงุฎุชุจุงุฑุงุช
beforeAll(() => {
  console.log('๐ง ุฅุนุฏุงุฏ ุงุฎุชุจุงุฑุงุช ุชุญุณููุงุช UX...');
}); 